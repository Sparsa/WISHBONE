// This is the implementation of WISHBONE B4 protocol
// The idea is to implement a simple worker that lights up a led if the input value is ODD else the light is off.
// Handshaking
// This is the worker agent
// RULE 3.30
// Workers may not respond any other workers when CYC_I is negatged
// PERMISSION 3.10
// if in standard mode the worker gurantees that it can keep pace with all Controller interfaces
// if the ERR_I and RTY_I signals are not used then the workers ACK_O = STB_I && CYC_I [both signal are workers]
// system should behave normally under these circumstances.
// OBSERVATION 3.25
// In standard mode Worker assert a cycle termination in resoponse to STB_I.
// TERMINATING Signals
//TERM_SIG = ACK_O || ERR_O || RTY_O ;

initially guarantee {
//[odd <- false]; // before operation the value should be false
}
always guarantee {
// RESET:
rst_i -> [odd <- false]; // if the reset comes we are making it false
// OBSERVATION 3.10
// SLAVE interfaces automatically negate [ACK_O], [ERR_O], and [RTY_O] when their [STB_I] is negated in standard mode
// in PIPELINE mode the asertions ACK_O, ERR_O, and RTY_O are done independently of STB_I, page 32.
//!STB_I -> !(ACK_O || ERR_O || RTY_O ); // I am currently implementing the standard mode so commenting this out
// in standard mode SLAVE interfaces assert a cycle termination signal in response to STB_I
// OBSERVATION 3.25, page 34, STB_I is only valid when CYC_I is valid.
// RULE 3.35
// In standard mode the cycle termination signals TERM_SIG must be generated in response to the logical and of CYC_I and STB_I
// PERMISSION 3.10, page 34
// In standard mode the Worker guarantees it can keep pace with all Insturctor interfaces and if the [ERR_O] and [RTY_O] are not used, then the 
// workers [ACK_O] may be tied to the logical and of the WORKERS STB_I and CYC_I inputs.
// Keeping it simple here, as we want to send ack immidiately when the STB_I and CYC_I is asserted.
//STB_I && CYC_I -> [ACK_O <- true] ; // this is wierd behavior, I was expecting STB_I && CYC_I -> ACK_O is same as the one I have written, but it is not, will it cause delay by one cycle????
// LOGIC of the Worker
// I am writing a function that checks if the input data is Odd, 
!rst_i && stb_i && cyc_i -> [odd <- checkOdd dat_i] && [ack_o <- true]; // I have combined the ACK_O logic and the odd logic here. I will write a function that checks if the data you put here is odd or not.
// PERMISSION 3.15
// Other signals, beside the previously mentioned two may be included in generating the TERM_SIG
// OBSERVATION 3.30
// The internal signals of reciever have to understand what is the cycle termination signal and when it is asserted
// For example ACK_I is used to terminate a local bus cycle. Also it can use ERR_O or RTY_O.
// RULE 3.40
// for minimum implementation the worker must have the following signals implemented
// Worker: ACK_O, CLK_I, CYC_I, STB_I and RST_I.
//RULE 3.45:
// If an worker supports the signals: 
// ERR_O and RTY_O ontop of ACK_O then the slave ** MUST NOT** assert more than one of these signals.
//ACK_O -> !ERR_O && !RTY_O; // When ACK_O is high the ther two is not high
//ERR_O -> !ACK_O && !RTY_O; // when ERR_O is high the other two is not high
//RTY_O -> !ERR_O && !ACK_O; // When RTY_O is high the other two is not high
// ** DO NOT ** use WORKER that supports ERR_O and/or RTY_O with instructor that do not support these. This will cause ** DEADLOCK** 

// RULE: 3.50:
// The workers ACK_O, ERR_O and RTY_O signals must be asserted and negated in response and negation of STB_I
// *** HOW TO WRITE THIS PROPERTY?***

// PERMISSION 3.30 
// The assertion of [ACK_O] ERR_O and RTY_O may be asynchronous to the CLK_I ???? which means you can directly connect the STB_I and ACK_O without any flipflops in between
// OBSERVATION 3.40 :: This asyncthronouse behaviour ensures that the interface can accomplish one data transfer per clock cycle, because you are getting reply back in the same clock cycle by means of the Comobologic
// plus it also makes the design much simpler.

// OBSERVATION 3.45 : The asynchronous assertion of ACK_O ERR_O and RTY_O could proof impossible to implemnt for example slave wait states are easiest implemented using a registered ACK_O 

//OBSERVATION 3.50 : in large high speed designs the asynchronous assertion of ACK_O ERR_O and RTY_O can cause unacceptable delays. Registered version of these signals can reduce the wait time. 
// PERMISSION 3.35: In some special cases such as point-to-point where there is a single worker connected with the instructor, then the worker always operates without wait states. ??
}  
